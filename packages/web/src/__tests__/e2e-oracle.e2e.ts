/**
 * E2E Oracle Test: verify our TypeScript evaluateFilter() agrees with the
 * real RSL Helper application's Sell Test for randomly generated filters + items.
 *
 * Requires a live RSL Helper instance + harness server.
 * Run with: npm run test:e2e
 * Replay:   E2E_SEED=12345 npm run test:e2e
 */
import { describe, it, expect } from "vitest";
import fc from "fast-check";
import * as fs from "node:fs";
import * as path from "node:path";
import { execSync } from "node:child_process";
import {
  ARTIFACT_SET_NAMES,
  evaluateFilter,
  generateFilter,
  serializeFilter,
} from "@rslh/core";
import type { Item, HsfFilter } from "@rslh/core";
import { quickStateToGroups } from "../quick-generator.js";
import { generateRulesFromGroups } from "../generate-rules.js";
import type { QuickGenState } from "../quick-generator.js";
import { arbQuickGenStateLight, arbItemsForState } from "./helpers/arbitraries.js";

// ---------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------

const BASE_SEED = Number(process.env.E2E_SEED) || Date.now();
const NUM_STATES = Number(process.env.E2E_STATES) || 5;
const ITEMS_PER_STATE = Number(process.env.E2E_ITEMS) || 20;
const TEST_DIR = process.env.RSLH_TEST_DIR || "/mnt/e/downloads/browser/rslh-test";
const POLL_INTERVAL_MS = 300;
const POLL_TIMEOUT_MS = 30_000;

const CMD_FILE = path.join(TEST_DIR, "harness-cmd.json");
const RESULT_FILE = path.join(TEST_DIR, "harness-result.json");
const READY_FILE = path.join(TEST_DIR, "harness-ready");
const STOP_FILE = path.join(TEST_DIR, "harness-stop");
const STATUS_IMG = path.join(TEST_DIR, "status.png");

// Install SIGINT handler: write the stop sentinel so the harness aborts
// mid-operation (between clicks) instead of continuing to move the mouse.
process.on("SIGINT", () => {
  console.log("\n[SIGINT] Writing harness stop sentinel...");
  try {
    fs.writeFileSync(STOP_FILE, "abort", "utf-8");
  } catch { /* best effort */ }
  process.exit(130);
});

// ---------------------------------------------------------------------------
// Item → Sell Test dropdown index mapping
// ---------------------------------------------------------------------------

/** Sorted set IDs as they appear in the ArtifactSet dropdown (no "All" entry). */
const SORTED_SET_IDS = Object.keys(ARTIFACT_SET_NAMES)
  .map(Number)
  .sort((a, b) => a - b);

/** Map set ID → dropdown index. */
const SET_ID_TO_DROPDOWN: Record<number, number> = {};
for (let i = 0; i < SORTED_SET_IDS.length; i++) {
  SET_ID_TO_DROPDOWN[SORTED_SET_IDS[i]] = i;
}

/**
 * MainStat dropdown mapping: stat ID → dropdown index.
 * Dropdown order: All(0) HP(1) HP%(2) ATK(3) ATK%(4) DEF(5) DEF%(6) SPD(7)
 *                 RES(8) ACC(9) CR%(10) CD%(11) HP/ATK/DEF%(12)
 *
 * Our stat IDs use isFlat=true for flat stats. The dropdown doesn't distinguish
 * flat vs %, so we map the stat ID directly. Items generated by arbItem always
 * use stat IDs from STAT_NAMES (1-8) which map to the percentage variants.
 * The Sell Test dropdown only has one entry per stat base, so we map as:
 *   statId 1 (HP%) → 2, statId 2 (ATK%) → 4, statId 3 (DEF%) → 6,
 *   statId 4 (SPD) → 7, statId 5 (C.RATE) → 10, statId 6 (C.DMG) → 11,
 *   statId 7 (RES) → 8, statId 8 (ACC) → 9
 */
const MAIN_STAT_DROPDOWN: Record<number, number> = {
  1: 2,  // HP%
  2: 4,  // ATK%
  3: 6,  // DEF%
  4: 7,  // SPD
  5: 10, // C.RATE
  6: 11, // C.DMG
  7: 8,  // RES
  8: 9,  // ACC
};

interface SellTestItem {
  artifactSet: number;
  artifactType: number;
  rank: number;
  rarity: number;
  mainStat: number;
  level: number;
  faction: number;
}

function itemToSellTestIndices(item: Item): SellTestItem {
  return {
    artifactSet: SET_ID_TO_DROPDOWN[item.set] ?? 0,
    artifactType: item.slot - 1,
    rank: item.rank - 1,
    rarity: item.rarity,
    mainStat: MAIN_STAT_DROPDOWN[item.mainStat] ?? 0,
    level: Math.floor(item.level / 4),
    faction: item.faction ?? 0,
  };
}

// ---------------------------------------------------------------------------
// Harness communication — direct file I/O
// ---------------------------------------------------------------------------

function sleep(ms: number): Promise<void> {
  return new Promise((r) => setTimeout(r, ms));
}

function stripBom(s: string): string {
  return s.replace(/^\uFEFF/, "").replace(/^\xEF\xBB\xBF/, "");
}

async function sendCommand(cmd: Record<string, unknown>): Promise<Record<string, unknown>> {
  // Remove stale result
  if (fs.existsSync(RESULT_FILE)) fs.unlinkSync(RESULT_FILE);

  // Write command
  fs.writeFileSync(CMD_FILE, JSON.stringify(cmd), "utf-8");

  // Poll for result, retrying reads to handle races
  const deadline = Date.now() + POLL_TIMEOUT_MS;
  while (Date.now() < deadline) {
    if (!fs.existsSync(RESULT_FILE)) {
      await sleep(POLL_INTERVAL_MS);
      continue;
    }
    // File exists — wait briefly for it to be fully written, then try to read
    await sleep(150);
    try {
      const raw = stripBom(fs.readFileSync(RESULT_FILE, "utf-8"));
      return JSON.parse(raw) as Record<string, unknown>;
    } catch {
      // File may have been removed or partially written — retry
      await sleep(POLL_INTERVAL_MS);
    }
  }
  throw new Error(`Harness timeout after ${POLL_TIMEOUT_MS}ms waiting for: ${cmd.action}`);
}

/** Check if the stop sentinel exists (written by harness-stop.sh or Ctrl+C). */
function isAborted(): boolean {
  return fs.existsSync(STOP_FILE);
}

async function loadHsfFile(filePath: string): Promise<void> {
  // Convert WSL path to Windows path
  let winPath = filePath;
  if (winPath.startsWith("/mnt/")) {
    winPath = winPath[5].toUpperCase() + ":" + winPath.slice(6).replace(/\//g, "\\");
  }

  const result = await sendCommand({ action: "load_hsf", filePath: winPath });
  if (!result.ok) {
    throw new Error(`load_hsf failed: ${JSON.stringify(result)}`);
  }
}

async function openSellSetup(): Promise<void> {
  const result = await sendCommand({ action: "open_sell_setup" });
  if (!result.ok) {
    throw new Error(`open_sell_setup failed: ${JSON.stringify(result)}`);
  }
}

async function setSellTestItem(item: SellTestItem): Promise<void> {
  const result = await sendCommand({ action: "set_sell_test_item", item });
  if (!result.ok) {
    throw new Error(`set_sell_test_item failed: ${JSON.stringify(result)}`);
  }
}

async function readStatus(): Promise<string> {
  const result = await sendCommand({ action: "read_status" });
  if (!result.ok) {
    throw new Error(`read_status failed: ${JSON.stringify(result)}`);
  }

  // OCR the status screenshot (single line mode)
  const text = execSync(`tesseract "${STATUS_IMG}" - --psm 7 2>/dev/null`, {
    encoding: "utf-8",
  }).trim();

  if (!text) throw new Error("OCR returned empty text");
  return text;
}

function parseVerdict(ocrText: string): "keep" | "sell" | "unknown" {
  const lower = ocrText.toLowerCase();
  if (lower.includes("sold")) return "sell";
  if (lower.includes("kept")) return "keep";
  return "unknown";
}

// ---------------------------------------------------------------------------
// Mismatch tracking
// ---------------------------------------------------------------------------

interface Mismatch {
  stateIndex: number;
  stateSeed: number;
  itemIndex: number;
  item: Item;
  sellTestItem: SellTestItem;
  expected: "keep" | "sell";
  actual: string;
  ocrText: string;
  state: QuickGenState;
  filter: HsfFilter;
}

// ---------------------------------------------------------------------------
// Test
// ---------------------------------------------------------------------------

describe("E2E Oracle: evaluateFilter vs RSL Helper", () => {
  it("should agree with RSL Helper Sell Test", async () => {
    // Check harness is running
    expect(
      fs.existsSync(READY_FILE),
      "Harness not running. Start with: ./scripts/harness-start.sh",
    ).toBe(true);

    // Verify connectivity
    const ping = await sendCommand({ action: "ping" });
    expect(ping.ok, "Harness ping failed").toBe(true);

    // Ensure Sell Setup and Sell Test panels are open
    await openSellSetup();
    await sleep(500);
    await sendCommand({ action: "open_sell_test" });
    await sleep(500);

    console.log(`\n=== E2E Oracle Test ===`);
    console.log(`Base seed:  ${BASE_SEED}`);
    console.log(`States:     ${NUM_STATES}`);
    console.log(`Items/state: ${ITEMS_PER_STATE}`);
    console.log(`Test dir:   ${TEST_DIR}\n`);

    const mismatches: Mismatch[] = [];
    let totalItems = 0;
    let totalPass = 0;

    for (let si = 0; si < NUM_STATES; si++) {
      if (isAborted()) {
        console.log(`\n[ABORT] Stop sentinel detected — ending test early`);
        break;
      }
      const stateSeed = BASE_SEED + si;
      console.log(`\n── State ${si + 1}/${NUM_STATES} (seed ${stateSeed}) ──`);

      // 1. Generate a random QuickGenState
      const [state] = fc.sample(arbQuickGenStateLight, { seed: stateSeed, numValues: 1 });
      console.log(`  Blocks: ${state.blocks.length}, Profiles: [${state.blocks.map((b) => b.selectedProfiles.join(",")).join("; ")}]`);

      // 2. Pipeline: state → groups → rules → filter → serialize
      const groups = quickStateToGroups(state);
      const rules = generateRulesFromGroups(groups);
      const filter = generateFilter(rules);
      const hsf = serializeFilter(filter);
      console.log(`  Rules: ${filter.Rules.length}`);

      // 3. Write .hsf and load into RSL Helper
      const hsfPath = path.join(TEST_DIR, `oracle-state-${si}.hsf`);
      fs.writeFileSync(hsfPath, "\uFEFF" + hsf, "utf-8");
      await loadHsfFile(hsfPath);
      // Give RSL Helper time to process the new filter
      await sleep(1000);

      // 4. Generate items and sample evenly
      const itemSeed = stateSeed + 1000;
      const [allItems] = fc.sample(arbItemsForState(state), { seed: itemSeed, numValues: 1 });
      const step = Math.max(1, Math.floor(allItems.length / ITEMS_PER_STATE));
      const sampledItems: Item[] = [];
      for (let j = 0; j < allItems.length && sampledItems.length < ITEMS_PER_STATE; j += step) {
        sampledItems.push(allItems[j]);
      }
      console.log(`  Generated ${allItems.length} items, testing ${sampledItems.length}`);

      // 5. Test each item
      for (let ii = 0; ii < sampledItems.length; ii++) {
        if (isAborted()) {
          console.log(`\n  [ABORT] Stop sentinel detected — ending test early`);
          break;
        }
        const item = sampledItems[ii];
        const expected = evaluateFilter(filter, item);
        const sellTestItem = itemToSellTestIndices(item);

        try {
          await setSellTestItem(sellTestItem);
          // Give RSL Helper time to evaluate
          await sleep(500);

          const ocrText = await readStatus();
          const actual = parseVerdict(ocrText);

          totalItems++;
          if (actual === expected) {
            totalPass++;
            console.log(`    [${ii + 1}/${sampledItems.length}] PASS  expected=${expected}  ocr="${ocrText}"`);
          } else {
            console.log(`    [${ii + 1}/${sampledItems.length}] FAIL  expected=${expected}  actual=${actual}  ocr="${ocrText}"`);
            mismatches.push({
              stateIndex: si,
              stateSeed,
              itemIndex: ii,
              item,
              sellTestItem,
              expected,
              actual: actual === "unknown" ? `unknown(${ocrText})` : actual,
              ocrText,
              state,
              filter,
            });
          }
        } catch (err) {
          console.log(`    [${ii + 1}/${sampledItems.length}] ERROR ${(err as Error).message}`);
          totalItems++;
          mismatches.push({
            stateIndex: si,
            stateSeed,
            itemIndex: ii,
            item,
            sellTestItem,
            expected,
            actual: `error: ${(err as Error).message}`,
            ocrText: "",
            state,
            filter,
          });
        }
      }
    }

    // 6. Write mismatch report
    const report = {
      seed: BASE_SEED,
      timestamp: new Date().toISOString(),
      totalItems,
      totalPass,
      totalFail: mismatches.length,
      mismatches,
    };

    const reportPath = path.join(TEST_DIR, "oracle-mismatches.json");
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2), "utf-8");

    console.log(`\n=== Results ===`);
    console.log(`  Total:  ${totalItems}`);
    console.log(`  Passed: ${totalPass}`);
    console.log(`  Failed: ${mismatches.length}`);
    console.log(`  Report: ${reportPath}`);

    if (mismatches.length > 0) {
      console.log(`\n  First mismatch:`);
      const m = mismatches[0];
      console.log(`    State seed: ${m.stateSeed}`);
      console.log(`    Item: set=${m.item.set} slot=${m.item.slot} rank=${m.item.rank} rarity=${m.item.rarity} mainStat=${m.item.mainStat} level=${m.item.level} faction=${m.item.faction}`);
      console.log(`    Expected: ${m.expected}, Actual: ${m.actual}`);
      console.log(`    OCR: "${m.ocrText}"`);
      console.log(`\n  Replay with: E2E_SEED=${BASE_SEED} npm run test:e2e`);
    }

    expect(mismatches.length, `${mismatches.length} mismatch(es) — see ${reportPath}`).toBe(0);
  });
});
